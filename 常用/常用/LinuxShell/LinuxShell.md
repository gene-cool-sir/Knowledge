# LinuxShell

安装操作系统

&#x20;(1).创建一个目录用来保存虚拟机文件

&#x20;(2).安装系统 (eth0,edit-勾选配置网卡)

&#x20;(3).系统连接(默认超级管理员root 密码设置: 123456)

&#x20;(4).客户端连接操作系统

&#x9;ssh  用户名@ip地址

客户端软件: cecureCRT xshell putty

虚拟机联网注意事项

&#x20;(1)虚拟机统一使用NAT方式连接

&#x20;(2)当虚拟机连接不上网

&#x20;   a)确定VMnet8网卡的IP地址(查看: route -n)&#x20;

&#x20;   b)检查服务VM开头的 NAT 和 DHCP 这2个服务(vmware NAT Service  vmware dhcp service)

&#x20;   c)虚拟机设置中设备状态 是否勾选 已连接

&#x20;   d)检查"虚拟网络编辑器"的NAT的相关设置(网段)

&#x20;(3)重启网卡

&#x20;   service network restart

&#x9;

&#x9;IP: 网络地址 (8位为一个)

&#x9;子网掩码: NETMAST: 在某一个网段

&#x9;网段用来判断计算机之间是否在同一网段:

&#x9;	网段 = IP的二进制 & 子网掩码二进制

&#x9;	eg.:ip 192.168.25.3

&#x9;		子网掩码: 255.255.255.0

&#x9;		网段: 192.168.109.0

&#x9;网关: GATEWAT: 网络 地址192.168.25.1

&#x9;域名解析: DNS&#x20;

&#x9;[www.baidu.com](http://www.baidu.com) ---> 远程DNS(域名解析服务器)(配置文件中

&#x9;					有对应的baidu.com对应的域名

&#x9;				\----> 返回baidu.com 的ip -->访问百度

&#x9;本地有一个hosts 域名映射文件; 若hosts文件未找到,则去

&#x9;远程DNS去寻找域名解析后的ip

&#x9;域名解析服务器:

&#x9;建议使用网关的IP即可,若配置远程其他的DNS服务器.

&#x9;当子网掩码一致

&#x9;网段一致

&#x9;网关

&#x9;\-----> 多台计算机可以

&#x9;虚拟机联网方式:

&#x9;	NAT:

&#x9;	桥接:

&#x9;	hostonly:本地访问,不能外部访问

&#x9;NAT(推荐使用):

&#x9;	vmware虚拟出路由器 (网关ip)---虚拟网络编辑器中

&#x9;	服务中虚拟出网卡

&#x9;	虚拟网卡与虚拟路由链接

&#x9;&#x9;

&#x9;	查看NAT模式的网关IP(虚拟网络编辑器中)

&#x9;	ip: (网关最后一位以上\~255)

&#x9;	netmask:255.255.255.0

&#x9;	gateway: 网关ip

&#x9;	dns:网关ip&#x20;

&#x9;&#x9;

&#x9;	主机真实网卡: ---> 真实路由器

&#x9;	VMware: 虚拟网卡(VMnet8) 需要配置一个网卡 , 然后链接外网

&#x9;&#x9;

&#x9;	子网ip(虚拟网卡vmnet8): 192.168.25.0&#x9;

&#x9;	子网掩码:255.255.255.0

&#x9;	网关IP:192.168.25.2&#x20;

&#x9;	配置NAT模式: <https://blog.csdn.net/lsc476782158/article/details/51721909>

&#x9;&#x9;

&#x9;桥接模式(不能保证ip是否冲突):

&#x9;	不是虚拟出网卡,而是和真实主机公用同一块网卡.

&#x9;	与真实路由相关 (ipconfig--> 以太网....)

&#x9;	IP:(IPV4换一个不同的)

&#x9;	netmask: 255.255.255.0

&#x9;	gateway: 网关ip&#x20;

&#x9;	DNS: 网关ip&#x20;

&#x9;&#x9;

&#x9;	局限性: IP段容易冲突,

&#x9;			换一个网络环境,则服务器的所有ip需要重新配置

&#x9;		&#x9;

&#x9;网络配置

&#x9;1、ip配置

&#x9;	-》ifconfig命令，查看网卡信息（ip）

&#x9;	-》修改ip配置文件

&#x9;		\- vi /etc/sysconfig/network-scripts/ifcfg-eth0

&#x9;		\- IPADDR=192.168.25.130&#x20;

&#x9;		\- NETMASK=255.255.255.0

&#x9;		\- GATEWAY=192.168.25.2

&#x9;		\- DNS=192.168.25.2

&#x9;2、配置域名

&#x9;	-》hostname 查看域名信息

&#x9;	-》临时修改 hostname xzb  (vi /etc/sysconfig/network)

&#x9;	-》永久修改 vi /etc/sysconfig/network

&#x9;3、配置网络映射

&#x9;	-》vi /etc/hosts

&#x9;	-》192.168.25.130 xzb  格式：ip + 主机名

机器克隆注意事项

&#x9;步骤:

&#x9;1\. 删除原来的网卡信息,并更改新网卡的名称未eth0&#x20;

&#x9;	vi /etc/udev/rules.d/70-persistent-net.rules

&#x9;2\. 配置网卡信息 vi /etc/sysconfig/netword-scripts/ifcfg-eth0

&#x9;3\. 更改主机名 vi /etc/sysconfig/network

&#x9;4\. 添加主机名映射	vi /etc/hosts &#x20;

&#x9;

查看IP地址(默认网卡eth0)

\# ifconfig   或者 ip a

连接系统

xshell --> 连接

Xshell:\\> ssh root\@192.168.24.128

上传资料

FileZlla

文本编辑器

Notepad++

/  表示根目录,Linux系统里面最上层的目录

文件或者目录名称严格区分大小写

drwxr-xr-x.  22 root root  4096 Oct 21 08:56 var

第一个字母-代表是文件, 第一个字母是d代表是目录

\# man 命令  查看帮助命令

\# pwd 打印当前目录

\# ls  列出当前目录有哪些文件(目录)

&#x9;-l  长格式列出文件属性

&#x9;-d  查看目录本身

&#x9;-a  查看所有文件(包括. 开头的隐藏文件)

\# touch	创建或者修改文件的时间(创建空文件)

\# mkdir  创建目录

&#x9;-p  递归的创建(多级目录的创建)

\# rm   删除文件

&#x9;-r  递归删除

&#x9;-f  强制删除

\# mv  移动或者重命名

&#x9;-i  提示

&#x9;-v  信息

&#x9;-u  修改或者不存在的文件

\# cp  拷贝

&#x9;-r  复制目录

\# cat  查看文件内容

&#x9;

\# file  查看文件内容类型

\# more 分屏查看文件内容

\# less&#x20;

&#x9;g : 首行

&#x9;G : 末尾

&#x9;b : 上一页

&#x9;space :下一页

&#x9;q : 结束

\# head -5 查看前5行内容

\# tail -10 查看文件后10行内容

绝对路径 和相对路径

.  ./ 当前目录

.. ../ 上级目录

\[root\@localhost 320]#

root\@localhost 当前登录用户

\~  当前用户的家目录

echo \~

ctrl+c 退出

du  统计文件或者目录大小

&#x20;   -s  统计容量综合

&#x20;   -h  友好显示

&#x20;   du -sh /etc  文件的大小

grep  查找匹配某个条件的行

&#x9;\# grep  'root' /etc/passed 匹配包含root字符的行

&#x20;\[扩展]

&#x9;-i

&#x9;-v  取反

&#x9;-A  后跟数字 匹配之后的行

&#x9;-B  匹配之前的行

&#x9;-n  显示行号

&#x9;-R  递归,包含所有文件下

&#x9;支持正则表达式

find  在目录中寻找符合条件的文件或者目录

&#x20;   find  查找的目标  匹配的条件

&#x9;-name 查找的名称

&#x9;-type 查找的类型

&#x9;       d  目录

&#x9;       f  文件

find /etc/ -name ' \*.conf'

\# find /etc/ -name '\*conf\*' -type f

\# find / -name 匹配条件

vi  vim  编辑文件

&#x9;

命令行模式

dd  删除光标所在的行(相当于剪切)

3dd  删除光标坐在的连续行

p  粘贴

yy  复制

u   撤销

gg   快读定位到第一行

G   快速定位到最后一行

n :  下一个匹配的词

N : 上一个匹配的词

插入模式

最后行模式

:set number 显示行号

:25 快速定位25行

:1,\$s/login/6666/g &#x20;

&#x20;  整个文件从第1行开始把login 替换成6666

:2,4,s/login/333/g&#x20;

&#x20;  整个文件从第二行开始到第四行 把login 替换成333

&#x9;s 替换

&#x9;g 全局

&#x9;

&#x9;

&#x9;

关机命令

init 0

重启命令

init 6

管道命令   |   &#x20;

\--就是把前一个命令的输出结果传递给后一个命令处理

\--哪些命令支持放在管道命令后面(more/head/grep/wc)

cat /etc/passwd | grep 'root'

cat  /etc/passwd | head -3

ifconfig | grep 'inet6 addr:'

追加\覆盖 >>     >

&#x9;\-- 把前一个命令的输出结果追加\覆盖到后一个命令进行处理

&#x9;head -3 /etc/passwd >> tmp.pass 追加

&#x9;head -3 /etc/passwd > tmp.pass  覆盖

&#x20;vi 命令: 命令行模式下面:  查找 /string

&#x9;							按字母n向下查找

&#x9;							按字母N向上查找

&#x9;						&#x9;

&#x9;						&#x9;

wc	-l 统计行

ps -ef | wc -l

cat /etc/passwd | grep 'root' | wc -l

Centos 操作系统两种工作界面

&#x9;\--图形界面

&#x9;\--字符界面(企业服务选择)

&#x9;\-- 切换vi /etc/inittab

&#x9;		 id:3:initdefault  (改变数字)

Centos 7种启动模式(了解)

\# Default runlevel. The runlevels used are:

\#   0 - halt (Do NOT set initdefault to this) 关机命令

\#   1 - Single user mode&#x20;

\#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)

\#   3 - Full multiuser mode 字符界面

\#   4 - unused

\#   5 - X11		图形界面

\#   6 - reboot (Do NOT set initdefault to this) 重启命令

/etc/passwd 保存系统用户的一些基本信息

/etc/group 保存系统用户组的信息

用户名:x:UID:GID

UID: 系统分配的整数数字

x : 密码是否加密

GID: 组ID

\--- 创建一个用户后,系统默认会创建一个与用户名同名的用户组

增加用户

useradd  用户名

cat /etc/passwd | grep '用户名'

增加用户组

\# groupadd 用户组

passwd 设置用户密码

passwd 用户名

echo '123456' | passwd --stdin user01

su 切换用户

su  - 用户名

id 用户名    查看用户信息

删除用户

userdel 用户名&#x20;

删除用户组

groupdel  用户组

用户家目录:

&#x9;\--创建完用户以后,默认会在/home目录下生成一个与用户名同名的目录

&#x9;   这个目录成为家目录

&#x9;  &#x20;

权限:

\# ls  -la

drwxr-xr-x. 2 test02 test02 4096 Nov  11  2010 .gnome2

d     文件类型

rwx   文件拥有者权限

r-x   文件拥有组权限

r-x	  其他所有人

只有root用户才能去修改用户/用户组命令文件的所有者

修改权限命令:

chmod

&#x9;chmod u-w /srv   (普通用户)

&#x9;chmod u+w /srv

&#x9;chmod u+w,g-r /srv

chown  &#x20;

&#x9;

Linux压缩和解压缩工具

tar.gz

&#x9;\--压缩:  tar -zcvf  压缩后的包名称.tar.gz  压缩的目标

&#x9;\--解压:  tar -zxvf  压缩后的包名称.tar.gz  \[-C  目标目录]

&#x9;\--例子:

&#x9;	tar -zcvf varlog.tar.gz /var/log/

&#x9;	z : 打包

&#x9;	c  : 创建

&#x9;	x  : 解压

&#x9;	v  : 显示过程

&#x9;	f  : 指定被处理的文件是 xxx.tar.gz .., f之后接文档名,不要再加参数

&#x9;	t  : 查看压缩包中的文件

tar.bz2

&#x9;\--压缩:  tar -jcvf  压缩后的包名称.tar.bz2  压缩的目标

&#x9;\--解压:  tar -jxvf  压缩后的包名称.tar.bz2  \[-C  目标目录]

&#x9;

&#x9;查看压缩包中的文件

&#x9;tar ztvf  压缩后的包名称.tar.gz

zip&#x20;

&#x9;\--压缩:  zip  压缩目标

&#x9;\--解压:  unzip  压缩包

rar

&#x9;默认不支持

&#x9;

&#x9;

磁盘分区

&#x9;主分区  +  扩展分区(需要再分逻辑分区才可以使用) <= 4

&#x9;在Linux系统默认所有设备文件都在/dev 下面

&#x9;/dev/sda  --硬盘1 sda1第一个分区 sda2 第二个分区 sda3第三个分区

&#x9;/dev/sdb  --硬盘2 ......

&#x9;/dev/sdc  --硬盘3 ......

&#x9;	s : 硬盘接口

&#x9;	d : disk 硬盘

&#x9;	abc  硬盘数

&#x9;\# fdisk -l 查看系统所有设备(硬盘)的分区情况

&#x9;(1) 系统一共有几块硬盘,每个硬盘的容量大小

&#x9;(2) 每个硬盘的分区情况(硬盘空间是否还有剩余)磁柱是否用完&#x20;

&#x9;&#x20;

&#x9;新增硬盘 : 关闭虚拟机,在启动页面,添加一块硬盘,重启, fdisk -l 查看

&#x9;

&#x9;fdisk /dev/sdb  操作sdb这块新增的硬盘

&#x9;	n : 创建分区

&#x9;		e : 扩展分区 p : 主分区  l: 逻辑分区(默认从5开始)

&#x9;	p&#x20;

&#x9;	磁柱默认从1开始, 回车

&#x9;	可以输入磁柱最大范围,也可输入 多少G|M|K

&#x9;	   (如果输出错了,删除分区, 按d)

&#x9;	+10G

&#x9;&#x9;

&#x9;	w : 保存分区

分区步骤:

&#x9;(1)fdisk 设备名称(/dev/sdb)  -- 进行分区

&#x9;(2)partx -a  /dev/sdb  (系统内核重新识别分区) 或者重启系统

&#x9;(3)格式化(选择文件系统ext4) mkfs.ext4  /dev/sdb2  格式化分区sdb2

&#x9;(4)挂载(临时)  mount  /dev/sdb2  /work   把sdb2挂载到/work(可自己创建) 目录

&#x9;	当在work目录下创建文件,使用的时候, 使用的空间则是sdb2的

&#x9;	若不想使用这个挂载点(卸载挂载点):   unmount  /work &#x20;

&#x9;	若想永久生效:

&#x9;		修改  vi  /etc/fstab

&#x9;		分区			挂载点		文件类型	默认....

&#x9;		/dev/sdb2		/work		ext4	  defaults  0 0

&#x9;	&#x9;

文件系统:  ext2  	ext3  	ext4 	xfs

&#x9;

block : Linux操作系统管理文件的最小(逻辑)单位

&#x9;	\-- 1k	2k	4k (有这些大小)

&#x9;&#x9;

扩展了解: parted分区	MBR  GPT

&#x20;

&#x20;软件包的管理   --centos

&#x9;.rpm    --使用RPM命令管理 (有比较强的依赖关系)

&#x9; rpm  -qa  | grep  包   &#x20;

&#x9;	qa 查找所有安装的包

&#x9;\--安装

&#x9;	rpm  -ivh   xxx.rpm&#x20;

&#x9;		i 安装  vh 显示安装的进度

&#x9;\--卸载&#x20;

&#x9;	rpm   -e   报名

&#x9;\--查看&#x20;

&#x9;	rpm -qa | grep 包名的一部分

&#x9;	rpm -qf  绝对路径b文件   : 查询文件b属于哪个安装的包

&#x9;&#x9;

&#x9;&#x9;

&#x9;yum 命令:&#x20;

&#x9;	\-- 用来管理rpm包

&#x9;	yum  list  : 列出可用的安装包(包括已安装的rpm包) 第一列 包名称; 第二列 包版本; 第三列 仓库(出现@符号表示安装过了);

&#x9;		yum  list  | grep  '要查找的安装包'

&#x9;	yum  -y  install  包名  : 安装软件包

&#x9;		-y : 跳过提示

&#x9;	yum	 -y  remove  报名    :  卸载软件包

&#x9;	yum  update 包名        : 升级

&#x9;&#x9;

&#x9;	配置yum仓库

&#x9;		\--常用的仓库地址  mirrors.163.com   mirrors.sohu.com   ...

&#x9;		\--仓库配置文件路径: /etc/yum.repos.d&#x20;

&#x9;		\--DNS解析

&#x9;			可以打开任意一个以.repos 文件,即可发现仓库地址

&#x9;			ping  公网查看网络是否通

&#x9;				202.96.209.5&#x20;

&#x9;				8.8.8.8

&#x9;				8.8.4.4&#x20;

&#x9;			ping  [www.baidu.com](http://www.baidu.com)  查看域名是否可以解析DNS

&#x9;			vi /etc/sysconfig/netword-scripts/ifcfg-eth0

&#x9;				配置DNS

&#x9;				DNS1=192.168....

&#x9;			service iptables restart&#x20;

&#x9;			更改主机映射:

&#x9;			vi  /etc/hosts      ip   主机名

&#x9;			设置主机名配置

&#x9;			vi /etc/sysconfig/network 		HOSTNAME=主机名

&#x9;			查看DNS映射文件

&#x9;			cat /etc/resolv.conf

&#x9;			nameserver  DNS1&#x20;

&#x9;			...

&#x9;		&#x9;

查看常用的系统管理命令

ifconfig  查看网卡ip

top		  查看系统整体资源(相当于windows中的任务管理器)

free 	  查看内存

&#x9;-m  按MB显示单位,不加按kb

netstat   :  查看端口情况

&#x9;-anltcp  参数组合	 &#x20;

&#x9;netstat  -an

&#x9;netstat  -tlp   监听tcp协议

&#x9;-a (all)显示所有选项，默认不显示LISTEN相关

&#x9;-t (tcp)仅显示tcp相关选项

&#x9;-u (udp)仅显示udp相关选项

&#x9;-n 拒绝显示别名，能显示数字的全部转化成数字。

&#x9;-l 仅列出有在 Listen (监听) 的服務状态

&#x9;-p 显示建立相关链接的程序名

&#x9;-r 显示路由信息，路由表

&#x9;-e 显示扩展信息，例如uid等

&#x9;-s 按各个协议进行统计

&#x9;-c 每隔一个固定时间，执行该netstat命令。

ps		查看进程

&#x9;ps  -ef&#x20;

&#x9;ps  -auxf

&#x9;

了解命令:&#x20;

&#x9;vmstat	虚拟内存命令

&#x9;iostat  磁盘和CPU信息

&#x9;mpstat	实时监控

&#x9;sar		系统活动情况

&#x9;&#x9;

kill   三四进程

&#x9;kill  -l  列出列表

&#x9;kill  -9   pid  杀死进程(强制) (第一个为pid, 第二个为ppid(父))

&#x9;kill  -15  pid  正常杀死进程

&#x9;

正则表达式

\[a-z]

\[A-Z]

\[0-9]

.    单个任意字符

\* 	 >=0&#x20;

\+	 >=1&#x20;

?    0 or 1

{n,m}   n <= 字符 < m&#x9;

{n,}

{,m}

sed:&#x20;

&#x9;查找:

&#x9;	sed   '匹配的条件/执行的动作'  文件

&#x9;	或者(支持管道命令)

&#x9;	cat /etc/passwd | sed  '匹配的条件/执行的动作'  文件

&#x9;替换 :  sed 's/old字符串/new字符串/g'&#x20;



&#x9;

awk:(取列)

&#x9;awk -F: '{print \$0}' /etc/passwd  (-F指定分割符)

环境变量(set):		系统--->对应多个用户

&#x9;用户环境变量	(.bash\_profile 文件   .bashrc文件)

&#x9;系统环境变量	系统环境变量(/etc/profile)

&#x9;

位置变量

&#x9;\-- 通常和脚本联合使用

&#x9;\$0		脚本名称

&#x9;\$1 \$2  \$3 ... \$9  脚本变量的位置参数

&#x9;	可以使用位置变量作为参数传递

&#x9;

sh  ssh脚本名称  执行脚本&#x9;

&#x9;sh  执行的脚本	脚本参数1  脚本参数2

&#x9;	若脚本中使用了位置参数"\$1" "\$3"  则会根据位置对应

&#x9;&#x9;

预定义变量

&#x9;由系统保留和维护的一组特殊的变量

&#x9;\$0   脚本名称

&#x9;\$!	 后台运行的最后一个进程pid号

&#x9;\$?    (程序上个命令是否执行成功)程序退出的代表 0 成功, 非0 失败

&#x9;\$\*    \$@ 代表参数的内容

&#x9;\$\$    代表当前进程的ID号

&#x9;\$#    代表当前shell的参数个数

&#x9;

&#x9;

&#x9;eg. echo \$?  上个命令是否成功; 0 成功 ; 非0 失败

&#x9;

自定义变量

&#x9;\--语法格式: 变量名称=值

&#x9;\--注意: = 两边不能有空格

&#x9;		变量名大小写敏感

&#x9;		变量名常量一般大写

&#x9;\--定义好的变量取值:

&#x9;	\$变量  \${变量}

&#x9;&#x9;

算术运算:

&#x9;\+ - \* / %

&#x9;\--\$((expression))

&#x9;\--\$\[表达式]

&#x9;\--expr  expression     (表达式之间用空格)

&#x9;	其中expression是算术表达式

&#x9;	eg. a=2 &#x20;

&#x9;		b=3

&#x9;		echo  \$((a+b))

&#x9;		echo  \$\[a+b]

&#x9;		expr  \$a + \$b

&#x9;	&#x9;

内置测试判断: 成功 与 失败

&#x9;\--test 测试表达式

&#x9;\--\[测试表达式] 最常见

&#x9;\-- 注意: 测试表达式和中括号之间一定要有空格

&#x9;eg. a=2  b=3&#x20;

&#x9;	test  \$a -lt \$b&#x20;

&#x9;	echo \$?    0成功  ,否则失败

&#x9;&#x9;

&#x9;	\[ \$a -lt \$b ]

&#x9;	echo \$?    0成功 , 否则失败&#x20;

&#x9;&#x9;

用于命令之间的链接符&#x9;

&& 逻辑与

&#x9;\-- cmd1 && cmd2 第一个成功了,才会执行第二个命令

&#x9;\-- test cmd1 && test  cmd2&#x20;

&#x9;\-- \[ cmd1 ] && \[ cmd2 ]

|| 逻辑或

&#x9;\-- cmd1 || cmd2  cmd1失败了才会执行cmd2

;  无逻辑关系

&#x9;\-- cmd1 ; cmd2   cmd1执行完之后,执行cmd2命令

&#x9;

&#x9;

数值比较

&#x9;-eq 等于则为真

&#x9;-ne 不能于为真

&#x9;-gt  大于则为真

&#x9;-ge 大于等于为真

&#x9;-lt 小于为真

&#x9;-le 小于等于为真

&#x9;

字符串比较

&#x9;\= 等于则为真

&#x9;!= 不相等为真

&#x9;-z 字符	字符串长度空则为真

&#x9;-n 字符		字符长度不为空则为真

&#x9;

&#x9;eg. a="i am"		记得加上引号,否则把 am作为了一个名李玲

&#x9;	b="you a"		记得加上引号, 否则把a做为了 一个命令

&#x9;	\[ "\$a" = "\$b" ] ; echo \$? 记得加上"" , 否则 i am= you a  不是一个完整的比较

&#x9;	数字也可以用"" 括起来,变量与字符空格隔开

&#x9;

用于表达式中的 链接符

&#x20;   \[ cmd1 -o  cmd2 ] 只要有一个成立,才真  或&#x20;

&#x9;test cmd1 -a  cmd2  2个都成立,才真  与

&#x9;	 !          非&#x20;

&#x9;&#x9;

文件的测试

&#x9;-e  文件名   	文件存在则为真

&#x9;-r	文件名	文件存在且可读为真

&#x9;-w	文件名	文件存在且可写为真

&#x9;-x	文件名	文件存在且可执行为真

&#x9;-s	文件名	文件存在且至少有一个字符(文件是否为空)

&#x9;-d 	文件名	文件存在且为目录

&#x9;-f	文件名	文件为普通文件且存在则为真

&#x9;-c	文件名	文件是否是字符型文件为真

&#x9;-b	文件名	文件是否为块

&#x9;

总结:

&#x9;\[ 表达式 ]

&#x9;test  表达式&#x20;

&#x9;test 表达式 &&/||/; test 表达式&#x20;

&#x9;test 表达式 -o/-a/! 表达式&#x20;

&#x9;\[ 表达式 ]

&#x9;\[ 表达式 ] &&/||/; \[ 表达式 ]

&#x9;\[ 表达式 -a/-o/! 表达式 ]

date

&#x9;\# date  -s  "时间"  修改系统时间,临时修改

&#x9;\# date '+%Y%m%d%H%M'  格式化时间

&#x9;\# date -d '7 day ago' '+%Y%m%d%H%M'   7天之前的时间

取字符串:

&#x9;a="20181107"

&#x9;echo \${a:2:3}  跳过2个字符,取3个字符

&#x9;



&#x9;a="123.log"



&#x9;

find 查找文件

&#x9;-type &#x20;

&#x9;-name

&#x9;-size

&#x9;-mtime

&#x9;\-

&#x9;

ls  /etc/shells   列出所有的shell解释器

脚本案例:

\#!/bin/bash

\# #号表示注释

\# shell脚本从上往下依次执行

命令&#x20;

通过bash/sh/source/ 运行脚本

bash  脚本

sh	  脚本&#x20;

source  脚本&#x20;

.     脚本 &#x20;

控制语句

&#x9;for语句

&#x9;语法1: &#x20;

&#x9;	for  变量  in 值1值2 ...值n

&#x9;		do

&#x9;		命令 ..

&#x9;		done

&#x9;语法2:

&#x9;	for ((初始化变量;结束循环条件;运算))

&#x9;		do

&#x9;		命令...

&#x9;		done

&#x9;

&#x9;eg.&#x20;

&#x9;for in {1..50}

&#x9;do

&#x9;mkdir \~/work/dir\$i

&#x9;done

&#x9;

&#x9;seq   : 预先执行命令

&#x9;

&#x9;for((i=1;i<=10;i++))

&#x9;	do&#x20;

&#x9;	SUM=\$((SUM+i))

&#x9;	done

&#x9;echo \$SUM

&#x9;

&#x9;while 语句:

&#x9;语法1:&#x20;

&#x9;	while  \[条件]

&#x9;		do

&#x9;		命令..

&#x9;		done

注意 若要放在一行 while \[条件] ; do  ... 用;隔开

&#x9;语法2:

&#x9;	while read -r line      (read -r  读取每行, line是变量名)&#x20;

&#x9;		do&#x20;

&#x9;		命令...

&#x9;		done&#x20;

&#x9;&#x9;

&#x9;

&#x9;eg.

&#x9;i=1&#x20;

&#x9;while \[ \$i -lt 10 ]

&#x9;do

&#x9;SUM=SUM\$((SUM+i))

&#x9;i=\$\[i+1]

&#x9;done

&#x9;echo \$SUM

&#x9;

&#x9;while  read -r  line

&#x9;do&#x20;

&#x9;echo  \$line&#x20;

&#x9;done < /etc/passwd

&#x9;读取文件的每行数据

if判断语句

&#x9;	语法1: (放在同一行需要用;隔开) if 和\[] 之间要有空格

&#x9;		if 条件

&#x9;		then

&#x9;			命令序列

&#x9;		fi&#x20;

&#x9;	&#x9;

&#x9;	语法2:

&#x9;		if 条件

&#x9;		then

&#x9;			命令序列&#x20;

&#x9;		else

&#x9;			命令序列&#x20;

&#x9;		fi

&#x9;	&#x9;

&#x9;	语法3:

&#x9;		if  条件

&#x9;		then

&#x9;			命令序列

&#x9;		elif 条件

&#x9;		then

&#x9;			命令序列&#x20;

&#x9;		...

&#x9;		else

&#x9;			命令序列&#x20;

&#x9;		fi&#x20;

&#x9;	&#x9;

case语句

&#x9;	语法1:

&#x9;	case  \$变量名 in&#x20;

&#x9;	条件1)

&#x9;		命令序列

&#x9;		;;

&#x9;	条件2)

&#x9;		命令序列

&#x9;		;;

&#x9;	....

&#x9;&#x9;



&#x9;	esac

&#x9;&#x9;

shell 函数

&#x9;语法1: (name: 函数名称)

&#x9;	name(){

&#x9;		命令序列

&#x9;	}

&#x9;&#x9;

&#x9;语法2:

&#x9;	function  name{

&#x9;		命令序列&#x20;

&#x9;	}

&#x9;调用的时候直接写name

&#x9;

计划任务

&#x9;

&#x9;一次性的计划任务

&#x9;	at

&#x9;	at 时间   指定当前时间执行计划任务

&#x9;		计划任务内容

&#x9;		ctrl+d结束

&#x9;		参数&#x20;

&#x9;			-l  :列出计划任务

&#x9;			-d  : 删除计划任务

&#x9;			..

&#x9;		&#x9;

&#x9;周期性的计划任务

&#x9;	crontab

&#x9;	a)开启crond服务

&#x9;		service crond  start

&#x9;	b) 设置开机自启动

&#x9;		chkconfig --list  列出系统中服务对的状态

&#x9;		\# chkconfig --list | grep crond&#x20;

&#x9;	c) 制定计划任务内容

&#x9;		crontab  -e

&#x9;			进入编辑模式(内容格式不能换行)





&#x9;			第一列: 分钟00\~59

&#x9;			第二列: 小时00\~23

&#x9;			第三列: 日1\~31

&#x9;			第四列: 月1\~12

&#x9;			第五列: 周0\~7 (0和7都表示周日)

&#x9;			第六列: 命令&#x20;

&#x9;	&#x9;

&#x9;		eg. 每周3凌晨2点 备份/etc/passwd文件

&#x9;		0 2 \* \* 3  cp /etc/passwd  /tmp/

&#x9;			每半个月清空一次/tmp (10号或25号 , 隔开)

&#x9;		0 0 10,25 \* \*  rm -rf /tmp/\*

&#x9;			每10分钟执行时间同步命令(/)



&#x9;			每天凌晨1点到6点执行(- 连续的范围)

&#x9;		0 1-6 \* \* \*  &#x20;

&#x9;	&#x9;

&#x9;	d) 重启crond服务

&#x9;		service crond restart&#x20;

&#x9;&#x9;

&#x9;	e) 参数&#x20;

&#x9;		crontab -l  列出计划任务&#x20;

变量:

&#x9;以字母或\_开始

&#x9;变量名=值  (=两边不要有空格)

&#x9;获取方式: \$变量名   \${变量名}

&#x9;''  :  强引用,原样输出

&#x9;""  :  弱引用,可输出变量名的值

&#x9;局部变量: 用local声明

&#x9;

用echo输出变量

&#x9;语法: echo \[option] \[string]

&#x9;	-n  不输出行尾的换行符

&#x9;&#x9;

环境变量操作

&#x9;脚本设置的环境变量,需要使用export,通知到脚本的环境

&#x9;export  \[-fnp] \[变量名称]=\[变量设置的值]

&#x9;export用于设置或显示环境变量

&#x9;-f 		: 代表变量名称中的函数名称

&#x9;-n		: 删除指定的变量,不会将输出到后续指令的执行环境中

&#x9;-p		: 列出所有shell赋予程序的环境变量

&#x9;bash的启动文件/登出文件:

&#x9;/etc/profile		系统默认,全局环境变量设置

&#x9;/etc/bashrc			系统范围函数与别名

&#x9;\~/.bash\_profile		用户定义,环境变量设置

&#x9;\~/.bashc			用户定义初始化文件

&#x9;\~/.bash\_logout		登出文件,退出shell时候执行

&#x9;

&#x9;env -i PATH=./:\$PAT eho.sh   临时改变环境变量值

&#x9;	-i :在执行eh0.sh脚本时,清空由父shell继承来的环境变量

&#x9;	-u  不带环境变量启动

&#x9;

&#x9;set 显示本地所有的变量

&#x9;unset  -v 变量  删除变量 (-v默认)

&#x9;unset -f 函数	删除函数

&#x9;

常用环境变量:

&#x9;HOME			用户专属目录

&#x9;PATH			外部命令的搜索路径 (:隔开)

&#x9;HISTSIZE		保存历史命令记录条数

&#x9;LOGNAME			当前登录名

&#x9;SHELL			当前使用shell类型

&#x9;LANG/LANGUAGE	语言相关的环境变量

&#x9;MAIL			当前用户的邮件存放目录

&#x9;PS1/PS2			PS1:基本提示符.root #  普通\$

&#x9;				PS2: 附属提示符 ">"

&#x9;			&#x9;

引用参数:

&#x9;	\$\* : 以一个单字符显示脚本所有传递参数

&#x9;	\$@ : 从参数1开始,显示所有脚本传递的参数

&#x9;	\$# : 参数的数量个数

&#x9;	\$! : 当前进程PID号

&#x9;	\$? : 最后一个命令退出状态,0 成功,否则失败

&#x9;	\$\~ : 当前shell选项

&#x9;&#x9;

&#x9;当参数多余9个, 可以用shift 移除参数,获取下一个参数

&#x9;

管道与重定向

&#x9;command  > file  标准输入重定向到文件中

&#x9;command  < file  标准输入修改为file

&#x9;command  >> file 将command的输出追加到文件末尾

&#x9;command1 | command2	将command1的标准输出到command2的标准输入

&#x9;

&#x9;eg. cat < a.txt > b.txt  从a.txt读入输出到b.txt &#x20;

获取文件前几行

&#x9;head  -n   file&#x20;

0 标准输入 1 标准输出 2 标准错误

1>  重定向标准输出

2>  重定向标准错误

0<	标准输入

&> 标准输出和标准错误

特殊文件

&#x9;/dev/null  读取和写入都为空

&#x9;/dev/zero

&#x9;/dev/tty

从标准输入中读取一行

&#x9;read \[-p -r -s -u ] variableName

&#x9;

grep命令检索文本

&#x9;	-b: 在每行之前添加找到该行时所在的块编号

&#x9;	-v : 显示所有不匹配的行

&#x9;	-x : 精确匹配的行

&#x9;	-y : 忽略字符的大小写

&#x9;	-c : 显示匹配行的计数

&#x9;	-E : 将制定模式作为扩展正则表达式

&#x9;	-F : 将每个制定的模式作为字符串而不是正则

ls 命令

&#x9;-a		列出所有条目包括.开头文件

&#x9;-c		索引节点,最近一次修改时间,用以排序

&#x9;-C		多列纵向排序

&#x9;-d		显示指定的目录

&#x9;-F		如果是目录,后面加上/

&#x9;-i		显示每个文件索引节点数

&#x9;

变量&#x20;

用户变量:

&#x9;	用户在shell编程过程中定义的变量,分为全局变量和局部变量

&#x9;	默认用户定义的shell变量为全局变量,局部变量需要加上local

&#x9;定义变量的语法:

&#x9;	varname=value

&#x9;	等号两边没有空格,如果多个单词需要使用引号括起来

&#x9;	使用变量的时候 \$varname 或者 \${varname}&#x20;

&#x9;删除变量:

&#x9;	unset varname

&#x9;查看变量值:

&#x9;	echo  \$varname  或者 echo  \${varname} 或者 echo "\$varname"

&#x9;

&#x9;特殊字符的转义:

&#x9;	\~	主目录

&#x9;	\`	pwd

&#x9;	\#	shell脚本注释

&#x9;	\$	变量表达式符号

&#x9;	&	将此命令置于命令末端,则让命令于后台运行

&#x9;	\*	字符通配符

&#x9;	(	启动子shell

&#x9;	)	结束子shell

&#x9;	\	转义下一个字符

&#x9;	\|	管道

&#x9;	{	开始命令块

&#x9;	}	结束命令块

&#x9;	\[	开始字符集通配符

&#x9;	]	结束字符集通配符

&#x9;	;	shell命令分隔符

&#x9;	'	强引用

&#x9;	"	弱引用

&#x9;	<	重定向输入

&#x9;	\>	重定向输出

&#x9;	!	管道行逻辑not

&#x9;	?	单个任意字符

&#x9;&#x9;

&#x9;	当位置变量超过9个,\${10} 获取第10个

&#x9;&#x9;

&#x9;字符串操作符:

&#x9;	1.确保变量有值存在

&#x9;	2.设置变量默认值

&#x9;	3.捕获未设置变量而导致的错误

&#x9;	4\. 删除匹配模式的便令值部分内容

&#x9;	\${varname:-word} 	: varname变量有值则返回该值,否则返回word

&#x9;	\${varname:=word}  	: 基本同上

&#x9;	\${varname:?message}	: varname有值,则返回该值,否则打印message信息,并退出当前脚本

&#x9;	\${varname:+word} 	: varname有值则返回该值,否则返回null

&#x9;	如果省略:则只判断变量是否存在

&#x9;&#x9;

&#x9;	变量替换与截取,模式匹配运算符

&#x9;	\${varname#pattern} 	: 如果模式匹配变量取值的开头处,则删除匹配的最短部分,返回剩余部分



&#x9;	\${varname##pattern} : 从头匹配, 匹配到靠后位置之前的都删除,返回剩余部分



&#x9;	\${varname%pattern}	: 从后往前匹配,匹配到的(第一个)后面字符删除,返回前面剩余字符



&#x9;	\${varname%%pattern} : 从后往前匹配,匹配到的所有字符删除,返回前面未匹配到的字符



&#x9;	\${varname/pattern/string} : 把匹配的第一部分替换为string

&#x9;			eg: a=abc.def.ghi  echo \${a/.//} --->abc/def.ghi

&#x9;	\${varname//pattern/string} : 把匹配到的所有字符替换为string

&#x9;			eg: a=abc.def.ghi	echo \${a//.//} --->abc/def/ghi

&#x9;		&#x9;



&#x9;				.\* 是.号之后的内容

&#x9;			eg: echo -e \${PATH//:/"\n"}

&#x9;	sed  			: 命令替换

&#x9;		echo \$PATH | sed 's/:/\n/g'

&#x9;	\${#varname}		: 返回变量值的字符个数

&#x9;&#x9;

&#x9;	echo \`pwd'		把命令作为标准输出

&#x9;&#x9;

位置变量:

&#x9;位置变量也称系统变量、位置参数，是shell脚本运行时传递脚本的参数,同时也标识shell函数内部的函数参数

&#x9;\$0\~9  \$0 脚本的名称  大于9个参数,\${10}...

&#x9;位置参数运用模式匹配运算符



&#x9;

&#x9;shift: 移除最左端的一个参数

&#x9;	执行shift之后\$1移除,\$2参数赋值给\$1, 以此类推

&#x9;	shift 2  截取2个参数

&#x9;&#x9;

环境变量:

&#x9;PATH			MAIL

&#x9;HOME			MAILCHECK

&#x9;COLUMNS			SHELL&#x20;

&#x9;EDITOR			TREM

&#x9;VISUAL			TMOUT

&#x9;FCEDIT			PROMPT\_COMMAND

&#x9;HISTFILE		PS1

&#x9;HISTSIZE		PS2

&#x9;HISTFILESIZE	PS3

&#x9;IFS				PS4

&#x9;LOGNAME			MANPATH

&#x9;LD\_LIBRARY\_PATH

&#x9;

&#x9;当需要修改环境变量的时候,使用export将变量修改写进启动文件

&#x9;

启动文件:

&#x9;/etc 目录下的文件提供全局设置.如果用户目录下有相同文件,则启用用户的

&#x9;/etc/environment 先运行文件中的环境变量

&#x9;	设置了最小搜索路径/时区/语言等用户环境

&#x9;	init开始的所有进程都要执行该文件

&#x9;

函数

&#x9;1\. shell执行命令的顺序

&#x9;	按照固定顺序依次寻找命令位置,而不是直接在PATH路径中查找.

&#x9;	别名 :  alias 	command="" 创建的命令

&#x9;	关键字 : if for

&#x9;	函数 :&#x20;

&#x9;	内置命令 : cd , pwd&#x20;

&#x9;	外部命令 : 脚本或可执行程序, 这才在PATH路径中查找

&#x9;&#x9;

&#x9;查看命令的来源(type 本身是内置命令)

&#x9;	type  commandName

&#x9;		(是否是别名,函数,内置命令,外部命令)

&#x9;函数使用规则:

&#x9;	1.函数必须先定义,后使用

&#x9;	2.函数在当前环境下运行,共享调用它的脚本中的变量,

&#x9;	  允许给位置参数赋值的方式向函数传递参数,函数体内部

&#x9;	  可以使用local限定词创建变量

&#x9;	3.函数中使用exit命令,会退出脚本. 如果想退回到原本调用函数的地方,则使用return命令

&#x9;	4.return语句返回函数执行最后一条命名的退出状态

&#x9;	5.使用内置export -f  可将函数导出到子shell中

&#x9;	6.函数保存在其他文件中,可以使用source或doc命令将他们装入脚本

&#x9;	7.函数可以递归调用,没有调用限制

&#x9;	8.函数可以使用declare -f 找到登录回话中定义的函数,

&#x9;&#x9;

&#x9;函数自动加载

&#x9;	source 文件 加载函数

&#x9;&#x9;

&#x9;函数的定义

&#x9;	function 函数名 () {}

&#x9;	函数名 () {}

&#x9;&#x9;

&#x9;函数删除

&#x9;	unset -f 函数名

&#x9;&#x9;

&#x9;函数对的参数和返回值

&#x9;	参数: 向函数传递位置参数

&#x9;	局部变量local: 内部变量在函数退出时消失

&#x9;	返回方式return: 若无指定return的参数,则返回最后一条命令的退出状态, 0\~255之间的整数

&#x9;&#x9;

&#x9;

条件控制与流程控制

&#x9;if/else语句(shell内置)

&#x9;	语法:\[]可选条件

&#x9;	if 条件

&#x9;	then

&#x9;		命令

&#x9;	\[elif 条件  then  命令....]

&#x9;	\[else 命令]

&#x9;	fi

&#x9;&#x9;

&#x9;退出状态:

&#x9;	函数以及命令的退出状态用0来表示成功,非0表示失败,而不是用Boolean

&#x9;	内置变量\$? 可以返回上一条语句的退出状态

&#x9;	\$? 取值:

&#x9;	0 		: 退出成功

&#x9;	\>0		: 在重定向或单词展开期间

&#x9;	1\~125	: 命令退出失败

&#x9;	126		: 命令找到,但无法执行

&#x9;	127		: 命令无法找到

&#x9;	\>128	: 命令收到信号而死亡

&#x9;&#x9;

&#x9;退出状态与逻辑操作

&#x9;	逻辑操作: NOT   AND    OR

&#x9;	NOT : 	条件判定失败的时候,执行某些操作

&#x9;			使用方法: ! 条件&#x20;

&#x9;	AND : 	一次测试多个条件

&#x9;			操作符: &&&#x20;

&#x9;	OR  : 	只要有一个条件成功

&#x9;			操作符: ||&#x20;

&#x9;		&#x9;

&#x9;条件测试

&#x9;	if 语句只能用于测试内容的退出状态, 不能用于检测表达式的值

&#x9;		检测表达式的值(test命令方式或者\[]方式):&#x20;

&#x9;			test  检测值

&#x9;			\[条件值]	注意\[ 条件 ], 条件前后要有空格

&#x9;		eg : if  test "2>3"

&#x9;			 if \[ "2>3" ]

&#x9;	test  表达式	如果表达式为true,则返回0

&#x9;	\[ 表达式 ]		表达式为true, 返回0&#x20;

&#x9;		0  : 成功

&#x9;		1  : 参数为false或丢失

&#x9;		\>1 : 发送错误

&#x9;	&#x9;

&#x9;	字符串比较:

&#x9;		str1=str2		相等

&#x9;		str1!=str2		不相等

&#x9;		str1\<str2		小于

&#x9;		str1>str2		大于&#x20;

&#x9;		-n str1			str1 非null 或长度大于0

&#x9;		-z str1 		str1 为null或长度为0&#x20;

&#x9;	&#x9;

&#x9;	文件属性检查

&#x9;		-b file		: file为设备文件

&#x9;		-c file 	: file 为字符设备文件

&#x9;		-d file 	: file 为目录

&#x9;		-e file 	: file 文件存在&#x20;

&#x9;		-f file  	: file 一般文件

&#x9;		-g file 	: file有设置setgid位

&#x9;		-h			: 符号链接

&#x9;		-L			: 符号链接&#x20;

&#x9;		-p			: 管道&#x20;

&#x9;		-r 			: 可读

&#x9;		-S			: 套接字

&#x9;		-s 			: 非空

&#x9;		-u 			: 社会setuid

&#x9;		-w 			: 可写

&#x9;		-x 			: 可执行

&#x9;		-O 			: file所有者

&#x9;		-G 			: file的组ID匹配自己的ID

&#x9;		file1 -nt file2	: file1 比file2新

&#x9;		file1 -ot file2 	: file1比file2旧

&#x9;	可以使用逻辑操作符,来参数判断

&#x9;&#x9;

&#x9;&#x9;

&#x9;case语句

&#x9;	语法(值: pattern):

&#x9;	case  表达式 in&#x20;

&#x9;		值1)

&#x9;			命令

&#x9;			;;

&#x9;		值2 | 值3)

&#x9;			命令

&#x9;			;;

&#x9;		...



&#x9;			命令&#x20;

&#x9;			;;

&#x9;	esac

&#x9;&#x9;

&#x9;

&#x9;for循环

&#x9;	语法:

&#x9;	for 变量名称 \[in list]

&#x9;	do

&#x9;		命令&#x20;

&#x9;	done

&#x9;&#x9;

&#x9;	遍历list中的所有对象, 执行\$变量名称相关的操作

&#x9;	其中, in list 若被省略,则默认为 in "\$@" 循环命令行的参数列表

&#x9;&#x9;

&#x9;&#x9;

&#x9;while/until循环

&#x9;	语法:&#x20;

&#x9;	while  条件

&#x9;	do&#x20;

&#x9;		命令&#x20;

&#x9;	done

&#x9;&#x9;

&#x9;	until  条件

&#x9;	do &#x9;

&#x9;		命令&#x20;

&#x9;	done

&#x9;&#x9;

&#x9;	区别: while 条件为真时, 继续执行&#x20;

&#x9;		  until 条件为真时, 停止执行

&#x9;	条件可以是: 简单的命令/列表,或者&& || 命令

&#x9;&#x9;

&#x9;跳出循环

&#x9;	break : 跳出循环&#x20;

&#x9;	continue: 执行下一次循环

&#x9;	跳出多重循环:

&#x9;	while 条件1

&#x9;	do &#x20;

&#x9;		...

&#x9;		while 条件2&#x20;

&#x9;		do&#x20;

&#x9;			....

&#x9;			break  2&#x20;

&#x9;		done&#x20;

&#x9;	done &#x20;

&#x9;&#x9;

&#x9;	break 2  : 跳出了2重循环

&#x9;&#x9;

&#x9;循环实例:

&#x9;	shift (截去第一个参数位置,并左移) while break&#x20;

&#x9;&#x9;

&#x9;getopt命令

&#x9;	可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式

&#x9;	getopt  optstring parameters

&#x9;	optstring 定义命令行有效的选项字母,还定义了哪些字母需要参数值

&#x9;	eg.

&#x9;	\#getopt ab:cd -a -b test1 -cd test2 test3

&#x9;	-a -b test1 -c -d -- test2 test3

&#x9;	optstring定义了四个有效选项字母:a,b,c,d.冒号（：）被放在了字母b后面，因为b选项需要一个参数值，当getopt命令运行时，它会检查提供的参数列表（-a -b test1 -cd test2 test3），并给予提供的optstring进行解析，它会自动讲-cd选项分成两个单独的选项，并插入双破折线来分割行中的额外参数。

&#x9;

&#x9;getopts 更高级

&#x9;	eg. \[ <https://blog.csdn.net/wh211212/article/details/53750366> ]

&#x9;	while  getopts :ab:c opt   获取\$opt 代表选项, 后有: 的 可通过 \$OPTAVG 获取&#x20;

&#x9;

&#x9;

正则表达式

&#x9;支持的工具:

&#x9;	grep 					匹配文本行

&#x9;	sed						改变输入流

&#x9;	awk python ..			处理字符串

&#x9;	more page less ...		文件查看

&#x9;	ed  vi  vim  ..			文件编辑

&#x9;&#x9;

&#x9;\b  元字符(单词边界符): 代表单词的开头或结尾

&#x9;	eg. 匹配hi   \bhi\b  匹配hi开头并结尾&#x20;

&#x9;

&#x9;grep命令

&#x9;	当匹配到

&#x9;&#x9;

&#x9;元字符

&#x9;	^		指定行或字符的开始

&#x9;	\$		指定行或字符串的结束

&#x9;	.		匹配一个非换行符的字符 (换行 \n)

&#x9;	\*		匹配0个或多个先前字符

&#x9;	\[...]	匹配方括号内任意一个字符

&#x9;	\		打开或关闭后续字符

&#x9;	\\(\\)	转义为()&#x20;

&#x9;	\n  	匹配n个字符

&#x9;	x\\{m,n\\} 匹配 x字符出现的区间

&#x9;	x{m,n} 	同上

&#x9;	\+		匹配一个或多个

&#x9;	?		匹配一个或0个

&#x9;	\| 		匹配前面或后面

&#x9;	()		匹配用括号括起来的正则表达式

&#x9;	\\<		指定单词的开始

&#x9;	\\>		指定单词的结束

&#x9;	\w		匹配文字和数字字符\[A-Za-z0-9]

&#x9;	\W		匹配一个或多个非单词字符,与\w相反&#x20;

&#x9;	\b 		单词锁定符, '\ba\b' 只匹配a&#x20;

&#x9;&#x9;

&#x9;	字符集方式:

&#x9;	\[:alnum:]		\[A-Za-z0-9]

&#x9;	\[:alpha:]		文字字符

&#x9;	\[:blank:]		空格和tab

&#x9;	\[:digit:]		数字字符

&#x9;	\[:graph:]		非空字符

&#x9;	\[:lower:]		小写字符

&#x9;	\[:cntrl:]		控制字符

&#x9;	\[:print:]		非空字符

&#x9;	\[:punct:]		标点字符

&#x9;	\[:space:]		所有空白字符

&#x9;	\[:upper:]		大写字符

&#x9;	\[:xdigit:]		十六进制数字(0-9,a-f,A-F)

&#x9;		使用时用\[] 包起来, \[\[:upper:]]

&#x9;	排序符号

&#x9;		将多个字符序列视为一个元素 \[.  和  .] 包起来

&#x9;		\[.cn.] 代表cn字符序列

&#x9;	等价字符集

&#x9;		视为等值的一族字符, 使用\[= 和 =] 将字符括起来

&#x9;		\[\[=e=]]&#x20;

&#x9;	&#x9;

&#x9;单个字符

&#x9;	一般字符: 文字、数字、空白字符、标点符，一般指本身

&#x9;	转义字符： \\

&#x9;	点字符  : 	.

&#x9;	方括号表达式: \[]

&#x9;&#x9;

&#x9;单个表达式匹配多个字符

&#x9;	{} ? +&#x20;

&#x9;文本匹配

&#x9;	^  \$

&#x9;	如果一起使用,期间的正则表达式就匹配了整个正则表达式或整行

&#x9;	^\$ 匹配空字符串或空行

&#x9;&#x9;

&#x9;运算符优先级

&#x9;	BRE中:

&#x9;		方括号符号

&#x9;		转义字符&#x20;

&#x9;		\[]表达式

&#x9;		后向引用表达式

&#x9;		区间表达式和星号表达式

&#x9;		联续

&#x9;		^\$

&#x9;	ERE中:

&#x9;		方括号符号

&#x9;		转义字符&#x20;

&#x9;		方括号表达式

&#x9;		分组()&#x20;

&#x9;		\* + ? {}&#x20;

&#x9;		无符号(连续)

&#x9;		^\$

&#x9;		|

&#x9;&#x9;

&#x9;罗马数字

&#x9;	....

&#x9;&#x9;

&#x9;案例: 解析电话号码

&#x9;	&#x20;

&#x9;&#x9;

基本文本处理

&#x9;排序文本sort命令

&#x9;	语法:

&#x9;	sort  \[arg] \[file1 file2 ...]

&#x9;	排序文件,对已排序的文件进行合并,并检查文件以确定他们是否排序

&#x20;

&#x9;	选项说明：

&#x9;	-c：检测给定的文件是否已经排序。如未排序，则会输出诊断信息，提示从哪一行开始乱序。

&#x9;	-C：类似于"-c"，只不过不输出任何诊断信息。可以通过退出状态码1判断出文件未排序。

&#x9;	-m：对给定的多个已排序文件进行合并。在合并过程中不做任何排序动作。

&#x9;	-b：忽略字段的前导空白字符。空格数量不固定时，该选项几乎是必须要使用的。"-n"选项隐含该选项。

&#x9;	-d：按照字典顺序排序，只支持字母、数值、空白。除了特殊字符，一般情况下基本等同于默认排序规则。

&#x9;	\--debug：将显示排序的过程以及每次排序所使用的字段、字符。同时还会在最前几行显示额外的信息。

&#x9;	-f：将所有小写字母当成大写字母。例如，"b"和"B"是相同的。

&#x9;	  ：在和"-u"选项一起使用时，如果排序字段的比较结果相等，则丢弃小写字母行。

&#x9;	-k：指定要排序的key，key由字段组成。key格式为"POS1\[,POS2]"，POS1为key起始位置，POS2为key结束位置。

&#x9;	-n：按数值排序。空字符串""或"\0"被当作空。该选项除了能识别负号"-"，其他所有非数字字符都不识别。

&#x9;	  ：当按数值排序时，遇到不识别的字符时将立即结束该key的排序。

&#x9;	-M：按字符串格式的月份排序。会自动转换成大写，并取缩写值。规则：unknown\<JAN\<FEB<...\<NOV\<DEC。

&#x9;	-o：将结果输出到指定文件中。

&#x9;	-r：默认是升序排序，使用该选项将得到降序排序的结果。

&#x9;	  ：注意："-r"不参与排序动作，只是操作排序完成后的结果。

&#x9;	-s：禁止sort做"最后的排序"。

&#x9;	-t：指定字段分隔符。

&#x9;	  ：对于特殊符号(如制表符)，可使用类似于-t\$'\t'或-t'ctrl+v,tab'(先按ctrl+v，然后按tab键)的方法实现。

&#x9;	-u：只输出重复行的第一行。结合"-f"使用时，重复的小写行被丢弃。

&#x9;		&#x9;

&#x9;	eg. sort -t: -k3n /etc/group

&#x9;&#x9;

&#x9;文本去重

&#x9;	语法:

&#x9;	uniq \[ -c | -d | -u ] \[ inFile \[ outFile ] ]

&#x9;	-c: 显示重复对的次数

&#x9;	-d: 显示重复的行

&#x9;	-u: 显示不重复的行

&#x9;&#x9;

&#x9;统计文本行数、数字、字符数

&#x9;	wc命令

&#x9;	-c  显示字符个数

&#x9;	-w	显示单词个数

&#x9;	-l  显示文件文本行数

&#x9;&#x9;

&#x9;&#x9;

&#x9;打印和格式化输出

&#x9;	pr命令

&#x9;	pr  文件 (每页包含66行文本,可通过pr  -l 参数改变)&#x9;

&#x9;	pr -h  打印标题  文件  &#x20;

&#x9;	pr -f  制表符替换空行

&#x9;	pr -c5  文件   将文件作为5栏输出

&#x9;	pr -t  文件     是文件不显示标题

&#x9;	   -o  每行缩进

&#x9;	  &#x20;

&#x9;命令格式化文本

&#x9;	fmt命令

&#x9;	fmt \[ -cstu ] \[-p<列起始字符串>] \[--help]\[--version]\[文件...]

&#x9;		-c : 每段前两排列缩排

&#x9;		-p : 仅合并含有指定字符串的列

&#x9;		-s : 拆开字数超出每列字符数的列,但不合并字数不足每列字符数的列

&#x9;		-t : 每列前2排缩排

&#x9;		-u : 每个字符之间都以空格字符隔开,每个句子之间以2个空格分割

&#x9;		-w : 设置每列的最大字符数

&#x9;	&#x9;

&#x9;使用fold限制文本宽度

&#x9;	语法

&#x9;	fold \[ -b ] \[ -s ] \[ -w 宽度] \[ File... ]

&#x9;		-b : 按字节计数宽度

&#x9;		-s : 阻断行

&#x9;		-w : 指定最大行宽, 默认80

&#x9;

&#x9;提取文本开头和结尾

&#x9;	head \[ -count | -c count | -n number ] \[ File ]

&#x9;		-count  : 从开头要显示的行数

&#x9;		-c count : 指定要显示的字节数

&#x9;		-n number : 指定从每一行要显示的指定文件的开头行数

&#x9;&#x9;

&#x9;	tail \[ -count ] 文件存在

&#x9;		-f  动态监测文件信息

&#x9;	&#x9;

&#x9;cut 从文本行中选出指定对的字节、字符或字段。

&#x9;	cut -c list \[ file ...]

&#x9;	cut -f list \[ -d delim ] \[ file... ]

&#x9;		-d : 规定了接受的字段分隔符

&#x9;		-f1,7 ; 获取字段列的第一列和第七列

&#x9;	&#x9;

&#x9;join 链接字段

&#x9;	join 文件1 文件2  -a&#x20;

&#x9;	读取文件1和文件2,根据链接文中的行(有对应),

&#x9;	把结果写到标准输出中,文件1和文件2必须为文本文件,

&#x9;	-1 field 由文件1指定字段来链接文件

&#x9;	-2 field 由文件2指定字段链接文件

&#x9;	-a1 由文件1指定&#x20;

&#x9;	-a2 由文件2指定&#x20;

&#x9;&#x9;

&#x9;&#x9;

&#x9;文本替换

&#x9;	tr替换字符

&#x9;		tr  str1 str2&#x20;

&#x9;		tr {-d | -s} str1&#x20;

&#x9;		tr 命令从标准输入删除或替换字符,并将结果写入标准输出

&#x9;	1.转换字符:

&#x9;		没有指定-d  把str1所包含的每一个字符都替换为str2中相同位置的字符

&#x9;	2.使用-d 标志删除字符

&#x9;		指定-d ,tr命令从标准输入中删除str1中包含的每一个字符

&#x9;	3.使用-s 标志去除序列

&#x9;		指定-s, tr命令去除包含在str1中的任何字符串中的除第一个字符以外的所有字符,

&#x9;	&#x9;

&#x9;	eg. tr 'a-z' 'A-Z' < textfile < newfile

&#x9;		tr 命令从textfile文件读入,将所有的a-z的字母替换为A-Z 的字母,并重定向到newfile文件

&#x9;	&#x9;

&#x9;		tr -d '\0' < textfile < newfile&#x20;

&#x9;			删除标准输入中给定的所有空格

&#x9;		tr -s  '\n' < textfile < newfile&#x20;

&#x9;			zai 重复字符序列中,删除除第一个字符以外的所有字符

&#x9;				当个换行,替换序列中的一个或多个换行

&#x9;			&#x9;

文件和文件系统

&#x9;文件分类:

&#x9;	普通文件

&#x9;	目录下

&#x9;	字符设备文件

&#x9;	块设备文件

&#x9;	符号链接文件

&#x9;&#x9;

&#x9;文件列表ls

&#x9;	显示目录或文件内容

&#x9;	ls \[arg] \[ file...]

&#x9;	显示目录内容

&#x9;	ls -f \[arg] \[ directory...]

&#x9;	-a 	所有文件包括隐藏文件

&#x9;	-d 目录&#x20;

&#x9;	-l 详细信息

&#x9;	-t 修改时间排序

&#x9;	-r 倒叙排

&#x9;	...

&#x9;&#x9;

&#x9;文件权限:

&#x9;	用户分组

&#x9;		owner 所有者

&#x9;		group 用户组

&#x9;		other 其他用户

&#x9;	&#x9;

&#x9;	更改文件所有者: chown

&#x9;	更爱文件或目录组所有权: chgrp

&#x9;	r 4

&#x9;	w 2

&#x9;	x 1&#x20;

&#x9;	\- 0&#x20;

&#x9;	eg. chmod 001 file1  该文件只能被执行

&#x9;	默认权限unmask

&#x9;	更改文件的权限chmod&#x20;

&#x9;	a	所有用户

&#x9;	u   当前用户&#x20;

&#x9;	g   用户组&#x20;

&#x9;	o   其他用户&#x20;

&#x9;	\+   添加

&#x9;	\-   删除&#x20;

&#x9;	r w x  权限位

&#x9;	eg chmod a+x  file1  所有file1的用于这都可以执行该文件

&#x9;	特殊权限:

&#x9;	s  : 任意存取该文件的所有者能使用的全部系统资源

&#x9;	t  : 所有用户暂时存取文件

&#x9;&#x9;

&#x9;使用touch修改文件时间

&#x9;	touch  文件1

&#x9;	语法

&#x9;	touch \[-a] \[-c] \[-m] \[-f] \[-r reffile] \[Time] \[-t Time] \[File | Directory]

&#x9;	-a  : 更改由file变量指定的文件的访问时间

&#x9;	-c  : 如果文件不存在,则不进行创建

&#x9;	-f  : 尝试强制touch运行&#x20;

&#x9;	-m  : 不要更改访问时间

&#x9;	-r RefFile : 使用RefFile变量指定文件的相应时间

&#x9;	Time : 以MMDDhhmm\[YY]的格式指定新时间戳记录的时间

&#x9;	MM :指定一年的哪个月

&#x9;	DD :指定一月的哪一天

&#x9;	hh :指定一天中的哪小时

&#x9;	mm : 指定一小时中的哪一分

&#x9;&#x9;

&#x9;寻找文件

&#x9;	find命令

&#x9;	find pathname -option \[-print -exec -ok ..]

&#x9;		pathname : find命令查找的目录路径

&#x9;		-print : 将匹配的文件输出到标准输出

&#x9;		-exec :对匹配的文件执行该参数所给的shell命令

&#x9;			   -exec '需要执行的命令或脚本' {}  \\;  {}和 \\;之间有空格

&#x9;			eg. find /etc -iname "\*rc" -exec cp {} /work \\;

&#x9;		-ok  : 同上,对于匹配的文件执行相应命令

&#x9;	&#x9;

&#x9;		-name : 按照文件名称查找文件

&#x9;		-perm : 按照文件权限查找文件

&#x9;		-prune: 不在当前目录中查找

&#x9;		-user : 按照文件属主来查找文件

&#x9;		-group : 按照文件所属的组来查找文件

&#x9;		-mtime -n +n : 按照文件的更改时间来查找文件, -n表示文件更改时间距现在n天以内

&#x9;					 +n 表示文件更改时间距离现在n天以前

&#x9;		-nogroup : 查找无效所属组的文件,该文件所属的组不在/etc/groups中

&#x9;		-nouser : 查找无效属主文件

&#x9;		-newer file1!fiel2 查找更改时间比file1新,比file2旧的文件

&#x9;		-type : 查找某一类型的文件

&#x9;			b : 设备文件

&#x9;			d : 目录

&#x9;			c : 字符设备文件

&#x9;			p : 管道文件

&#x9;			l : 符号链接文件

&#x9;			f : 普通文件

&#x9;		-size n : 查找文件长度为n块的文件, 一块= 0.5kb&#x20;

&#x9;		-depth : 先查找当前目录中的文件,再查找子目录中的文件

&#x9;		-fstype : 查找位于某一类型文件系统中的文件

&#x9;		-mount : 在查找文件时不跨越文件系统mount点

&#x9;		-follow: 当遇到符号链接文件,就跟踪至链接所指向的文件

&#x9;		-cpio : 文件备份到磁带设备中

&#x9;	&#x9;

&#x9;		与操作时间相关:

&#x9;			-amin n : 系统中最后n分钟访问的文件

&#x9;			-atime n :系统中最后 n\*24 小时访问的文件

&#x9;			-cmin n : 系统中最后n分钟被改变状态的文件

&#x9;			-mmin n  :  最后n 分钟改变数据的文件

&#x9;			-mtime n : 最后n\*24小时被改变的文件

&#x9;		&#x9;

&#x9;遍历文件

&#x9;	xargs 命令 : 后跟命令没有限制

&#x9;	eg.

&#x9;		find /tmp -type f -print | xargs file&#x20;

&#x9;		find /etc -type f | xargs grep "nameserver"

&#x9;	&#x9;

&#x9;比较文件

&#x9;	comm 和diff命令

&#x9;	comm比较排序后文件

&#x9;		comm  file1  file2

&#x9;		逐行比较: 分为3列

&#x9;		第一列: 第一个文件file1的行

&#x9;		第二列: 第二个文件file2的行

&#x9;		第三列: 两个文件相同的行

&#x9;		参数:&#x20;

&#x9;		-1 : 不显示只在第一个文件出现的列

&#x9;		-2 : 不显示只在第二个文件出现的列

&#x9;		-3 : 不显示都出现过的列

&#x9;	&#x9;

&#x9;	diff比较文件:

&#x9;		diff  file1 file2&#x20;

&#x9;		与第一个文件相比，第二个文件发生了哪些变化

&#x9;		结果中的字母: a=add,c=change,d=delete

&#x9;		eg: 2,4c2,4 的含义是：第一个文件中的第\[2,4]行(注意这是一个闭合区间，包括第2行和第4行)需要做出修改才能与第二个文件中的\[2,4]行相匹配。

&#x9;		-c : 通过+ - 来表示第一个文件的某些行是增加或者删除才能与第二个文件匹配

&#x9;		-u :&#x20;

&#x9;	&#x9;

&#x9;文件系统与磁盘分区

&#x9;	磁盘: 是一个可写的设备, 磁盘上有许多的磁道

&#x9;		  磁道的读取器可以在磁盘飞转时读写磁盘.

&#x9;		  由于一块磁盘容量大,为了便于管理,进行磁盘分区

&#x9;		 &#x20;

&#x9;	将磁盘分区作为设备文件,进而通过/dev目录中特殊文件使用文件I/O 机制

&#x9;&#x9;

&#x9;	fdisk -l  查看磁盘分区

&#x9;&#x9;

&#x9;分区格式和安全性

&#x9;	ext2 ext3 ext4 ...

&#x9;&#x9;

&#x9;mkfs命令

&#x9;	在一个指定的设备上制作一个新的文件系统,

&#x9;	mkfs命令初始化卷标/文件系统卷标/启动块

&#x9;&#x9;

&#x9;mount命令

&#x9;	指示操作系统,文件系统在指定位置可用&#x20;

&#x9;&#x9;

&#x9;&#x9;

流编辑sed

&#x9;可以从管道的标准输入接收数据进行编辑

&#x9;

&#x9;sed -e 'd' /tmp/abc 从abc读入一行到缓冲区就删除一行,源文件abc不做修改

&#x9;sed -e '5d' /tmp/abc 从abc读入的第5行在缓冲区进行删除

&#x9;sed -e '1,5d' /tmp/abc 第1到5行之间

&#x9;

&#x9;sed 使用的正则表达式用 /表达式/  两个/包起来

&#x9;sed -e '/^#/d' /etc/rc.local | more 把读入缓冲区的注释删除

&#x9;

&#x9;d   删除

&#x9;p   打印&#x20;

&#x9;s   替换&#x20;

&#x9;n   显示行&#x20;

&#x9;sed -e 's/需要替换的字符/替换后的字符/g' abc &#x20;

&#x9;sed -e '1,5s/需要替换的字符/替换后的字符/g' abc &#x20;

&#x9;

&#x9;多命令组合

&#x9;sed -e '=' -e 'p' abc   执行=打印行号,执行p 打印行&#x20;

&#x9;或者 sed -e '=;p' abc   多个命令用;隔开

&#x9;

&#x9;

文本处理器AWK

&#x9;awk命令分为3部分

&#x9;awk 命令本身

&#x9;要执行的命令内容: {print \$0} 打印整行

&#x9;输入文件

&#x9;awk '{print \$0}' abc   只有print的时候表示打印全部内容 \$0 代表整行

&#x9;awk -F: '{print "第一列:" \$1 "\t第二列:" \$2 }' /etc/passwd

&#x9;	这里加入空格不起作用 需要用引号括起来的空格或制表符才能print出空格效果

&#x9;head -10 /etc/passwd | awk -F":" '{print "User:" \$1 "\tShell: " \$7}'

&#x9;多个分隔符 (利用正则表达式)

&#x9;	-F"\[\t]+" 一个或多个制表符分割

&#x9;&#x9;

&#x9;BEGIN和END代码块

&#x9;	输入前的初始化		处理输入过程	处理完所有输入后的工作

&#x9;	使用-f 参数将awk脚本传递到命令中  &#x20;

&#x9;	vi fs.awk&#x20;

&#x9;	\#!/bin/bash

&#x9;	BEGIN {

&#x9;		FS=":"

&#x9;	}

&#x9;	{

&#x9;		print "USER: " \$1 "\tSHELL: " \$7

&#x9;	}

&#x9;	执行 : head -10 /etc/passwd | awk -f fs.awk&#x20;

&#x9;	等价于 head -10 /etc/passwd | awk -F":" '{print "USER: " \$1 "\tSHELL" \$7}'

&#x9;	BEGIN使用FS接收分割参数

&#x9;	单行语句使用-F后跟分割参数

&#x9;&#x9;

&#x9;	END代码块:

&#x9;		vi search.awk&#x20;

&#x9;		\#!/bin/bash

&#x9;		BEGIN{

&#x9;		\# 打印提示信息,只在初始化运行一次

&#x9;			print "How many people with nologin?"

&#x9;		}

&#x9;		\#awk处理输入对的过程,将每一条记录与正则nologin匹配,如果匹配上

&#x9;		\#就执行{} 中的内容

&#x9;		/nologin/{++adder}&#x20;

&#x9;		END {

&#x9;		\#统计nologin出现次数

&#x9;			print "'nologin' appears "adder" times."

&#x9;		}

&#x9;	&#x9;

&#x9;		执行: awk -f search.awk /etc/passwd&#x20;

&#x9;	&#x9;

&#x9;	匹配模式:

&#x9;		/正则表达式/ {匹配后需要做的操作}

&#x9;	&#x9;

&#x9;	awk -F":" '/bash/{print \$1}' /etc/passwd&#x20;

&#x9;		分割后的字符匹配上bash的行打印第一列

&#x9;	&#x9;

&#x9;	多项模式匹配,在脚本中例如search.awk&#x20;

&#x9;		/nologin/{++adder}

&#x9;		/bash/{++bash}

&#x9;		换行在写一个匹配模式

&#x9;		或者 awk -F: '/bash/{print \$1} ; /nologin/{print \$1}' /etc/passwd

&#x9;	&#x9;

&#x9;变量与数组:

&#x9;	内建变量: FS &#x20;

&#x9;	自定变量: 如 上面 adder&#x20;

&#x9;		自定义变量默认空串,当需要数值计算时默认0

&#x9;	内建变量:

&#x9;		FILENAME  当前输入文件的名称

&#x9;		FNR		  当前文件输入的记录数

&#x9;		FS 		  字段分隔符(支持正则,默认为空)

&#x9;		NF 		  当前记录的字段数

&#x9;		NR		  在工作的job数

&#x9;		OFS		  输出字段分割字符

&#x9;		ORS		  输出记录分割字符

&#x9;		RS 		  输入记录分隔符

&#x9;&#x9;

&#x9;	数组:&#x20;

&#x9;		site\[google]="我是google"

&#x9;		数组把google作为索引, 数组自动增长

&#x9;		delete  site\[index] 删除元素&#x20;

&#x9;		delete site 删除site这个数组所有元素

&#x9;	&#x9;

&#x9;算术运算:

&#x9;	awk 'BEGIN{print "3+2=" 3+2}'

&#x9;	awk 'BEGIN{print "2^10=" 2^10}'



&#x9;

&#x9;判断与循环(在{}中书写,和java差不多)

&#x9;	{

&#x9;		if (表达式) {

&#x9;			执行操作;

&#x9;		}

&#x9;	}

&#x9;

&#x9;	{

&#x9;		if(表达式) {

&#x9;			执行操作;

&#x9;		}else {

&#x9;			执行操作;

&#x9;		}

&#x9;	}

&#x9;&#x9;

&#x9;	在命令行中或脚本中使用

&#x9;&#x9;

&#x9;	{

&#x9;		if(表达式) {

&#x9;			执行操作;

&#x9;		} else if(表达式) {

&#x9;			执行操作;

&#x9;		} else {

&#x9;			执行操作;

&#x9;		}

&#x9;	}

&#x9;

&#x9;	{

&#x9;		while(条件) {

&#x9;			执行操作;

&#x9;		}

&#x9;	}

&#x9;&#x9;

&#x9;	{

&#x9;		do {

&#x9;			执行操作;

&#x9;		} while (条件)

&#x9;	}

&#x9;&#x9;

&#x9;	{

&#x9;		for (x=1;x<=4;x++) {

&#x9;			执行操作;

&#x9;		}

&#x9;	}

&#x9;

&#x9;	break 和continue 同java&#x20;

&#x9;

&#x9;

&#x9;多条记录

&#x9;&#x9;

&#x9;

&#x9;格式化输出:

&#x9;	printf 	格式化字符串打印到stdout

&#x9;	sprintf 返回可以复制给变量的格式化字符串

&#x9;&#x9;

&#x9;	支持转义字符

&#x9;	c		ASCII字符

&#x9;	s		字符串

&#x9;	d		十进制

&#x9;	ld      长十进制

&#x9;	u		十进制无符号&#x20;

&#x9;	lu      十进制无符号长整数

&#x9;	x        十六进制整数&#x20;

&#x9;	lx

&#x9;	o        八进制整数&#x20;

&#x9;	lo &#x20;

&#x9;	e        科学计数法

&#x9;	f        浮点数&#x20;

&#x9;	g       选用 e或f中较短的一种形式

&#x9;	\-        左对齐修饰符

&#x9;	\#        显示8进制前加0, 十六进制加0x

&#x9;	\+        显示使用 d e f g 转换整数时,加上 + -

&#x9;	0        用0而不是空白符填充所有显示的值

&#x9;&#x9;

&#x9;&#x9;

&#x9;字符串函数

&#x9;	sub(/reg/,newsubstr,str)	只替换第一个匹配字符串

&#x9;	gsub(/reg/,newsubstr,str)    替换所有

&#x9;	index(str,substr)      返回子串的索引位置

&#x9;	length(str) 		返回字符串长度

&#x9;	match(str,/reg/)	如果在str找到正则匹配的床,则出现它的位置,否则0

&#x9;	split(str,array,sep) 使用分隔符sep把字符串分解成数组array&#x20;

&#x9;	substr(str,position\[,length]) 返回从position开始的length个字符

&#x9;	toupper(str)    对字符串进行大小写转换

&#x9;	sprintf("fmt",expr) 对expr 使用printf格式说明

&#x9;&#x9;

&#x9;算术运算&#x20;

&#x9;	sin(x)

&#x9;	cos(x)

&#x9;	int(x)

&#x9;	atan2(x,y)&#x20;

&#x9;	log(x)

&#x9;	sqrt(x)

&#x9;	rand()

&#x9;	srand(x)

&#x9;&#x9;

&#x9;sed/awk单行脚本

&#x9;

&#x9;&#x9;

进程

&#x9;程序是为了完成某种任务而设计的软件,进程是运行中的程序

&#x9;

&#x9;创建进程fork()

&#x9;	父进程创建子进程,完成工作

&#x9;

&#x9;查看进程

&#x9;	ps : 当前时间点上系统进程的状态

&#x9;		ps -aux &#x20;

&#x9;		ps  -ef&#x20;

&#x9;		PID TTY          TIME CMD

&#x9;		PID : 进程的ID值,全局唯一

&#x9;		PPID : 父进程ID,创建了此进程的哪个进程ID

&#x9;				pstree 可查看进程树

&#x9;		%CPU : 进程占用CPU的百分比

&#x9;		%MEM : 占用内存百分比

&#x9;		NI : 进程的NICE值,数值越大,占用CPU时间较少,进程的优先级低

&#x9;		VSZ : 进程虚拟大小

&#x9;		RSS :驻留中页的数量

&#x9;		TTY :终端ID

&#x9;		STAT :进程状态

&#x9;		TIME :进程消耗CPU的时间

&#x9;		COMMAND : 进程的名称和参数

&#x9;	top : 查看系统一段时间进程的动态信息

&#x9;

&#x9;进程与任务调度

&#x9;	启动进程2个途径:

&#x9;		手工启动 : 前台启动和后台启动

&#x9;		调度启动 :

&#x9;			前台启动:输入命令

&#x9;			后台启动: 在命令末尾加上& 符号

&#x9;			command &  : 进程运行后,shell就直接返回

&#x9;			前台进程转后台进程: ctrl+z ,该进程暂时处于挂起状态

&#x9;			后台进程转前台进程: fg

&#x9;

&#x9;jobs 命令&#x20;

&#x9;	显示 当前shell被挂起的进程和后台进程的状况

&#x9;	jobs&#x20;

&#x9;	-l	: 提供每一个作业的信息,包括作业好,状态...

&#x9;	-n	: 显示对吼一次通知停止或退出的作业

&#x9;	-p	: 显示选定的作业的进程组

&#x9;&#x9;

&#x9;fg 命令

&#x9;	移动当前环境中的后台作业到前台来

&#x9;	fg \[jobId]

&#x9;	jobId :&#x20;

&#x9;		%Number 通过作业编号引用

&#x9;		%String 引用名称以特定字符串开头的作业

&#x9;		%?String 引用名称中包含特定字符串的作业

&#x9;		%+OR%% 引用当前作业,%-引用前一个作业

&#x9;		该命令内置命令

&#x9;

&#x9;bg 命令&#x20;

&#x9;	将暂挂的作业作为后台作业运行

&#x9;	bg \[JobId]

&#x9;		同上&#x20;

&#x9;

&#x9;信号:

&#x9;	ctrl+c 产生的信号只能发送给前台进程

&#x9;	kill -l : 查看系统支持的信号

&#x9;&#x9;

&#x9;inittab配置文件初始化linux

&#x9;	init 命令&#x20;

&#x9;	init 0  关机

&#x9;		 1  单用户字符界面

&#x9;		 2  不具备网络文件系统的多用户字符界面

&#x9;		 3  具有网络功能的多用户字符界面

&#x9;		 4  保留不用

&#x9;		 5  具有网络功能的图形用户界面&#x20;

&#x9;		 6  重启系统

&#x9;		&#x20;

&#x9;管道命令 |&#x20;

&#x9;

&#x9;调度系统任务(cron进程):

&#x9;	crontab  用于调度重复性系统任务

&#x9;	at  	 用于在特定时间调度单个系统任务

&#x9;	通过cron.deny cron.allow  at.deny 控制命令

&#x9;	crontab:

&#x9;		从临时目录操作文件

&#x9;		执行记账摘要命令

&#x9;		使用df 和ps 捕获系统快照

&#x9;		执行每日安全监视

&#x9;		运行系统备份&#x20;

&#x9;		运行fsck -n  列出任何磁盘问题

&#x9;		列出在特定月份中未使用的文件

&#x9;		生成每月记账报告

&#x9;		.....

&#x9;	-e	: 创建或编辑crontab文件

&#x9;	-l	: 验证文件内容

&#x9;	-r	: 删除crontab文件

&#x9;	可以通过编辑etc/cron.d/cron.deny文件将用户名添加到该文件中,拒绝访问

&#x9;	/etc/cron.d/cron.allow 文件中添加用户名,指定访问限制于指定的用户

&#x9;&#x9;

&#x9;	crontab  -l  \[username] 显示指定用户的任务&#x20;

&#x9;&#x9;

&#x9;	分钟: 0-59

&#x9;	小时: 0-23

&#x9;	月中某天: 1-31

&#x9;	月份: 1-12

&#x9;	星期中某日: 0-6 (0=星期天)

&#x9;&#x9;

&#x9;	使用特殊字符遵循的规则:

&#x9;		使用空格分割每个字段

&#x9;		使用逗号分割多个值

&#x9;		使用链接字符- 指定某一范围

&#x9;		使用\* 号作为通配符包括所有可能的值

&#x9;	&#x9;

&#x9;	crontab中的每个命令只占一行,即使这一行非常长,不识别额外的回车

&#x9;	cron.dency 拒绝哪些用户创建,访问..

&#x9;	cron.allow  允许哪些用户创建,访问...

&#x9;&#x9;

&#x9;	at 特定时间执行单个命令任务

&#x9;		at \[-m] time \[date]

&#x9;		-m : 在作业完成后发送邮件

&#x9;		time: 指定作业调度的小时

&#x9;		date: 指定月份的前3个或更多字母,一周中的某日或关键字today或tomorrow

&#x9;	ctrl+d 保存退出

&#x9;&#x9;

&#x9;		-r  删除&#x20;

&#x9;		-l  列出&#x20;

&#x9;&#x9;

&#x9;进程窗口/pro

&#x9;	proc : 虚拟文件系统

&#x9;		是一种内核和内核模块用来向进程发送信息的机制

&#x9;		这个为文件系统可以使得和内核内部数据结构进行交互,获得进程相关有用的信息

&#x9;		/proc 存在于内存之中,而不是硬盘上

&#x9;	/proc/cpuinfo CPU信息

&#x9;	/proc/meminfo 物理内存/交换空间等信息

&#x9;	/proc/mounts 以加载的文件系统列表

&#x9;	/proc/devices 可用设备的列表

&#x9;	/proc/filesystems 被支持的文件系统

&#x9;	/proc/modules 以加载的模块

&#x9;	/proc/version 内核版本

&#x9;	/proc/cmdline 系统启动输入的内核命令行参数

&#x9;&#x9;

&#x9;	文件中的每一个编号子目录,代表一个进程PID

&#x9;&#x9;

&#x9;Linux 线程&#x20;

&#x9;	线程是在共享内存空间中并发的躲到执行路径,他们共享一个进程资源

&#x9;&#x9;

&#x9;&#x9;

10超级工具

&#x9;修改登录shell和切换shell

&#x9;&#x9;

&#x9;SSH

&#x9;	对所有传输的数据进行加密,防止DNS和IP欺骗,传输的数据经过压缩,加快传输数独.

&#x9;	而Telnet /pop/ftp 明文传输,不安全

&#x9;&#x9;

&#x9;	提供了2中级别的安全验证:

&#x9;		基于口令的安全验证,只要知道账号和口令,就可以远程登录主机

&#x9;		基于秘钥的安全认证,自己创建一对秘钥,把公钥放在需要访问的服务器上

&#x9;			,客户端发起请求时,提示用秘钥进行安全登录

&#x9;			,服务器把接收到的公钥与家目录下的公钥进行比对,如果一致

&#x9;			服务器就用公钥加密,并返回给客户端软件,

&#x9;			客户端软件再次用私钥解密,再发送给服务器

&#x9;	&#x9;

&#x9;使用SSH登录步骤

&#x9;	1:生成秘钥对

&#x9;		ssh-keygen -d&#x20;

&#x9;		可以输入秘钥对所需的密码也可不输入

&#x9;	2: 把公钥上传到服务器

&#x9;		ssh-copy-id -i /home/xzb/.ssh/id-dsa.pub xzb\@192.168.25.130&#x20;

&#x9;		把公钥文件内容追加到authorized\_keys文件中,下次登录直接在此文件中查找

&#x9;	3\. sz id\_dsa 下载私钥文件在本地客户端

&#x9;	4\. 登录 ssh xzb\@192.168.25.130&#x20;

&#x9;&#x9;

&#x9;

&#x9;使用SSH工具拷贝文件

&#x9;	scp拷贝

&#x9;	scp 文件 主机名@ip

&#x9;		-r  允许递归拷贝目录

&#x9;	&#x9;

&#x9;	sftp拷贝文件

&#x9;	&#x9;

&#x9;screen工具

&#x9;	screen   开启一个执行shell的全屏窗口,可以执行任意shell程序和shell窗口同

&#x9;		screen 后跟要执行的程序或命令

&#x9;		exit 退出

&#x9;	&#x9;

&#x9;&#x9;

&#x9;nohup命令可以湖绿SIGUP(进程终止)信号

&#x9;	nohup \<command> \[argument...] &&#x20;

&#x9;

&#x9;

&#x9;下载源文件

&#x9;配置配置文件信息

&#x9;编译 make

&#x9;安装 make install

&#x9;

&#x9;vim&#x20;

&#x9;	工作模式:

&#x9;		常态模式

&#x9;		插入模式

&#x9;		命令列模式

&#x9;	y^ 复制到行首

&#x9;	y\$ 复制到行尾

&#x9;	yG 复制至文件尾部

&#x9;	y1G复制文件首部

&#x9;&#x9;

&#x9;	/ 向后匹配查找

&#x9;	? 向前匹配查找

&#x9;	n 向后

&#x9;	N 向前

&#x9;&#x9;

&#x9;&#x9;

11\. 编程实战

&#x9;日期清理程序

&#x9;	删除旧日志,保存新日志,使得日志暂有空间保持在一定范围

&#x9;系统监控程序

&#x9;&#x9;

&#x9;&#x9;

&#x9;

&#x9;&#x9;

&#x9;	&#x9;

&#x9;&#x9;

&#x9;

&#x9;&#x9;

&#x9;&#x9;

&#x9;	&#x9;

&#x9;&#x9;

&#x9;&#x9;

&#x9;&#x9;

&#x9;&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;	&#x9;

&#x9;

&#x9;

&#x9;&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;

&#x9;
